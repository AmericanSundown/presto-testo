// filename: upnp_tc_api.js
// author: Piotr Musiol - pmusiol@opera.com
// description:
// 	  set of functions specific for UPNP tests.
//    To be able to run more than one test per Opera Instance, each test operates on unique ids, which is both send and broadcasting and which is filtered while searching. That allows us to run many tests parallelly, not only within one browser instance but also with many gogi builds tested in the same network. That's why most of the functions require "ID" parameter.


//---------------------
// set of global params of properties which are rather constant, but can be changed

// in some point of testing and creating tests process it was nessesarry to diverse the server, description and links inside description url. For now, it's the same again.
 var COMMAND_ADDRESS = getUrl();
 var DESCRIPTION_ADDRESS = getUrl();
 var DESCRIPTION_COMMANDS = getUrl();
 var DISCOVERY_TIME = getDiscoveryTime();
//Opera downloads description only once per UPNP_NOTIFY_THRESHOLD_MS (currently - 10s)
var DESCRIPTION_REFETCH_DELAY = 10000;
//from UPnP specification:
 var UPNP_SSDP_HOST = '239.255.255.250:1900';

// preffix which is used for getNetworkServices - used in discoverServices()
 var UPNP_PREFIX = 'upnp:';

// parameter which allows to switch XHR
 var ASYNC_XHR = (get('async')?((get('async')=='true')?true:false):true);
var DOMAIN = 'opera-com';

//maximum age of service in seconds between two "alives"
var MAX_AGE = 1800;
//might be turned off to hide some of information on consle.
var DEBUG = true;



// controlDevice
//    adds to our python server another description for new device, and broadcast it's existence.
// params:
//  - ssdp : (REQUIRED) defines messages type - it might be either "alive" (default) or "byebye".
//  - id : (REQUIRED) basic device id
//  - ignore_sending_description : set true to bypass setting description (some tests needs some specific descriptions or it's lack).
//  - service_list : optional parameter - some tests require customized list of services, otherwise list is generated by getServiceList(id);
//

function controlDevice(ssdp ,id, ignore_sending_description ,service_list){
	if(!service_list)
		service_list = getServiceList(id);
	if(!ssdp)
		ssdp = 'alive';
	if(!ignore_sending_description)
		sendMockData('set_description',{
			'description' : createDescription(id,false,service_list),
			'id': id});
	for(var i = 0; i < service_list.length; i++)
		broadcastNotifyMsg(id,ssdp,service_list[i].serviceTypeWithDomain);
}

// discoverServices
//    makes Opera to start searching for UPnP devices, by running navigator.getNetworkServices with proper params - this function is essential for all tests.
// params:
//	- id : (REQUIRED) basic device id
//  - on_discover : function to be fired after devices are discovered. It gets one parameter - NetworkServices object - it's main function is to be a list of all discovered services
//  - on_change : function to be fired after each service state's change. It gets 3 params : available (true or false), NetworkService object, and it's index number on discovered services list.
//  - on_service_available : function fired after .onServiceUnavailable and  .onServiceAvailable event, which occures after another fitting to filter device is found or lost. It gets one parameter - NetworkServices object
//  - service_list : as in startMe function, some tests require custom service list. If not provided, default value will be generated from getServiceList(id);
//  - on_error : function to be set up as errorCallback function of GetNetworkServices(); If not provided, additional test position will be added and set as failed. It gets one parameter - error object
//

function discoverServices(id,on_discover, on_change, on_service_available, service_list,on_error){
	if(!service_list)
		service_list = getServiceList(id);
	var search_services = [];
	for(var i = 0; i < service_list.length; i++){
		search_services[i] = UPNP_PREFIX + service_list[i].serviceTypeWithDomain;
	}
	if(!on_error){
		on_error = function(error){
			addTest('[errorCallback] error.code: ' + error.code,'error_' + id);
			finishTest(false,'error_' + id);
		}
	}
	navigator.getNetworkServices(search_services, function(services) {
		msg('Initial number of services ' + services.servicesAvailable,'search','search id: ' + search_services[0]);
		if(on_discover)
			on_discover(services);
		if(on_change)
			applyOnchangeToServices(services, on_change);
		services.on_service_available = on_service_available;
		services.onserviceavailable = function(){
			msg('service available number has changed : ' + services.servicesAvailable,'search','search id: ' + id);
			if(services.on_service_available)
				services.on_service_available(services);
		};
		services.onserviceunavailable = services.onserviceavailable;
	},on_error);
}


// applyOnchangeToServices
//    basic help subfunction for discoverServices() - it's not used outside parent function. If on_change function is provided, it applies this function to proper events.
//
function applyOnchangeToServices(services, on_change){
	for (var i = 0; i < services.length; ++i){
		(function(service) {
			service.on_change = on_change,
			service.i = i,
			service.onserviceonline = function() {
				msg('service state change: ONLINE');
				if(service.on_change)
					service.on_change(true,service,service.i);
			}
			service.onserviceoffline = function() {
				msg('service state change: OFFLINE');
				if(service.on_change)
					service.on_change(false,service,service.i);
			}
		}(services[i]));
	}
}

// for generating unique id for each testset
function getId(){
	return parseInt(1000000*Math.random());
}

// next functions are pretty understandable, they are used for device description and in some modifications in testcases.
function getDeviceName(id){
	return 'urn:' + DOMAIN + ':device:opera_js_test';
}

function getDeviceType(id){
	return 'opera_js_test';
}

function getServiceList(id,sub,service_sub){
	if(!sub)
		sub = '';
	if(!service_sub)
		service_sub = '';
	services = [{
		'SCPDURL' : DESCRIPTION_COMMANDS + 'jstestService'+id+'Dsc'+sub,
		'controlURL' :  DESCRIPTION_COMMANDS + 'jstestService'+id+sub,
		'eventSubURL' : DESCRIPTION_COMMANDS + 'jstestService'+id+'Event'+sub,
		'serviceType' : getServiceName(id) + service_sub,
		'serviceTypeWithDomain' : getServiceNameWithDomain(id) + service_sub,
		'serviceIdWithDomain' : 'urn:' + DOMAIN + ':serviceId:OperaTestDummyService'+id+'id1'+sub
	}];
	return services;
}
function getServiceName(id){
	return 'service:OperaTestDummyService'+id+':1';
}
function getServiceNameWithDomain(id){
	return 'urn:' + DOMAIN + ':' + getServiceName(id);
}
function getUuid(id){
	return 'uuid:opera-test-'+id;
}
function getUrl(){
	var ip = get('ip');
	if(ip)
		return 'http://' + ip + ':8000/';
	else
		return 'http://127.0.0.1:8000/';
}
function getDiscoveryTime(){
	var discoveryTime = get('discovery_time');
	if(discoveryTime)
		return discoveryTime * 1;
	else
		return 3000;
}


// sendMockData
//     sends XHR message to python server with the proper path and params

function sendMockData(path,params){
	try{
		var xhr = new XMLHttpRequest();
		xhr.onreadystatechange = function(){
				if (xhr.readyState == 4){
					if (xhr.status == 200){
						var res = xhr.responseText;
						//msg('!RES: ' + res);
					}
					else
						msg('!ERROR- xhr status: ' + xhr.status + ': ' + xhr.statusText,'msg_error',path);
				}
			}
		xhr.open('POST', COMMAND_ADDRESS + path, ASYNC_XHR);
		xhr.setRequestHeader('Content-Type', 'text/plain; charset="utf-8"');
		if(typeof(params) == 'string')
			var data = params.replace(new RegExp("'", 'g'),'"');
		else
			if(typeof(params) == 'object')
				var data = JSON.stringify(params);
			else
				var data = '';
		xhr.send(data.trim());
		if(DEBUG) msg('!SEND: ' + COMMAND_ADDRESS + path,'send',data);
	}
	catch(e){
		msg('Exception: ' + e);
	}
}


// createDescription
//     creates XML with description as a string value.
// params:
//	- id : (REQUIRED) basic device id
//  - settings : object with few possible arrays to set, to create custom "noise" in description file. For example, when settings.remove = ['deviceType']; , deviceType field in xml will be removed.
//  - service_list : as in startMe function, some tests require custom service list. If not provided, default value will be generated from getServiceList(id);
//

function createDescription(id,settings,service_list){
	var friendlyName = 'Opera UPnP test device';
	var manufacturer = 'Opera Software';
	var manufacturerUrl = 'http://www.opera.com/';
	var deviceType = getDeviceType(id);
	var uuid = getUuid(id);

	if(!service_list)
		service_list = getServiceList(id);

	var xml = '<?xml version="1.0"?><root xmlns="urn:schemas-upnp-org:device-1-0">';
		xml += '<specVersion><major>1</major><minor>0</minor></specVersion>';
		xml += '<device>';
		 xml += '<deviceType>' + deviceType + '</deviceType>';
		 xml += '<friendlyName>' + friendlyName + '</friendlyName>';
		 xml += '<manufacturer>' + manufacturer + '</manufacturer>';
		 xml += '<manufacturerURL>' + manufacturerUrl + '</manufacturerURL>';
		 xml += '<UDN>' + uuid +'</UDN>';
		xml += '</device>';
		xml += '<serviceList>';
		for (var i = 0; i < service_list.length; i++){
			xml += '<service>';
				xml += '<SCPDURL>' + service_list[i].SCPDURL + '</SCPDURL>';
				xml += '<controlURL>' + service_list[i].controlURL + '</controlURL>';
				xml += '<eventSubURL>' + service_list[i].eventSubURL + '</eventSubURL>';
				xml += '<serviceType>' + service_list[i].serviceTypeWithDomain + '</serviceType>';
				xml += '<serviceId>' + service_list[i].serviceIdWithDomain + '</serviceId>';
			xml += '</service>';
		}
		xml += '</serviceList></root>';

		if(settings){
			if(settings.remove){
				for(var i = 0; i < settings.remove.length; i++)
					xml = xml.replace(new RegExp("<" + settings.remove[i] + ">.*<\/" + settings.remove[i] + ">",'i'),'');
			}
			if(settings.spoil){
				for(var i = 0; i < settings.spoil.length; i++)
					xml = xml.replace(new RegExp("<" + settings.spoil[i] + ">",'i'),'');
			}
			if(settings.spareFields){
				for(var i = 0; i < settings.spareFields.length; i++){
					var pos = xml.indexOf("<" + settings.spareFields[i].inside + ">") + ("<" + settings.spareFields[i].inside + ">").length;
					xml = xml.substr(0,pos) + '<' + settings.spareFields[i].field + '>' + settings.spareFields[i].value + '</' + settings.spareFields[i].field + '>' + xml.substr(pos);
				}
			}
		}
	return xml;
}


// broadcastNotifyMsg
//     prepares and sends to python server NOTIFY header to be broadcasted via UDP
// params:
//   - id (REQUIRED) : as always
//   - ssdp (REQUIRED) : 'ssdp:alive' or 'ssdp:byebye'
//   - nt : NT value for header of NOTIFY message.
//   - settings : similar to settings from createDescription - to create customable, spoiled messages without some fields.
//

function broadcastNotifyMsg(id, ssdp, nt, settings){
	var uuid = getUuid(id);
	if(!settings)
		settings = {};
	var header = 'NOTIFY * HTTP/1.1' + "\r\n";
		header += 'HOST: ' + UPNP_SSDP_HOST + "\r\n";
		if(!settings.no_maxage) header += 'CACHE-CONTROL: max-age = ' + MAX_AGE + "\r\n";
		if(!settings.no_location) header += 'LOCATION: ' + DESCRIPTION_ADDRESS + 'get_description?' + id + "\r\n";
		if(nt)
			header += 'NT: ' + nt + "\r\n";
		else
			header += 'NT: uuid:' + uuid + "\r\n";
		header += 'NTS: ssdp:' + ssdp + "\r\n";
		if(!settings.no_server) header += 'SERVER: OperaTest UPnP/1.0 OperaTest/1.0' + "\r\n";
		var usn = uuid;
		if(nt)
			usn += '::' + nt;
		if(!settings.no_usn) header += 'USN: ' + usn + "\r\n";
		header += "\r\n";
	sendMockData('broadcast_msg',{'data' : header});
}
